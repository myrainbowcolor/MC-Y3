print = function(...)
	if ... == nil then
		gameapi.print_to_dialog(3, "nil")
		return
	end
	if type(...) == "table" then
		gameapi.print_to_dialog(3, tostring(...))
		return
	end
	local cubeTb = { ... }
	local length = #cubeTb
	if length > 10 ^ 2 then
		gameapi.print_to_dialog(3, table.concat(cubeTb, "	"))
	else
		local str = ""
		for i = 1, length, 1 do
			str = str .. tostring(cubeTb[i]) .. "	"
		end
		gameapi.print_to_dialog(3, str)
		-- string.format("%s", str)
	end
	-- Recycle garbage generated by splicing

end

onLinePrint = function(...)
	local player = up.player(1)
	if ... == nil then
		player:msg("nil")
		return
	end
	if type(...) == "table" then
		player:msg(tostring(...))
		return
	end
	local cubeTb = { ... }
	local length = #cubeTb
	if length > 10 ^ 2 then
		player:msg(table.concat(cubeTb, "	"))
	else
		local str = ""
		for i = 1, length, 1 do
			str = str .. tostring(cubeTb[i]) .. "	"
		end
		player:msg(str)
		-- string.format("%s", str)
	end
	-- Recycle garbage generated by splicing

end

-- 设置触发器全局变量
--- @param varName string
---@param value any
function setTrigerGloableVar(varName, value)
	if type(value) == "boolean" then
		GameAPI.set_trigger_variable_boolean(varName, value)
	elseif type(value) == "table" then
		GameAPI.set_trigger_variable_table(varName, value)
	end
end

-- 获取触发器全局变量
--- @param varName string
--- @return boolean
function getTrigerGloableVar(varName)
	return GameAPI.get_trigger_variable_boolean(varName)
end

print("EG=> The Util library is loaded!")

--=====================================================================================--

--- @class Actor

--- @type table<integer, thread>
_gUdefCoroutinePool = {} -- 自定义线程池

-- 自定义唤醒事件
function udefDispatchEvent(event, ...)
	local parameterList = { ... }
	local co = coroutine.create(function()
		while true do
			coroutine.yield(event, parameterList)
		end
	end)
	table.insert(_gUdefCoroutinePool, { ["co"] = co, ["ev"] = event })
end

-- 自定义注册事件
function udefRegisterEvent(event, func)
	for _, v in pairs(_gUdefCoroutinePool) do
		local bool, _event, parameterList = coroutine.resume(v.co)
		if event == _event then
			func(table.unpack(parameterList))
			return v
		end
	end
end

-- 取消唤醒事件
function removeUdefDispatchEvent(event)
	for k, v in pairs(_gUdefCoroutinePool) do
		if event == v.ev then
			table.remove(_gUdefCoroutinePool, k)
			break
		end
	end
end

-- 延时器(ms)
--- @param delayTime number
function wait(delayTime)
	local curTime = os.time()
	while true do
		if os.time() - curTime >= delayTime / 1000 then
			break
		end
	end
end

-- vector类型数据检查
--- @param ... Vector
--- @return Vector
function vectorCheck(...)
	if not ... then error("EG=> argument is nil") end
	if type(...) ~= "table" then error("EG=> argument type is not Vector") end
	local vectorArr = { ... }
	for i = 1, Util:getTableLength(vectorArr), 1 do
		vectorArr[i].x = vectorArr[i].x or 0
		vectorArr[i].y = vectorArr[i].y or 0
		vectorArr[i].z = vectorArr[i].z or 0
	end
	return table.unpack(vectorArr)
end

-- 打印类表型数据类型的子集, 多个参数时会打印值的并集
--- @param ... Vector|table|Cube|CubeModel
function dump(...)
	if not ... then print("nil") return end
	local arr = { ... }
	local length = Util:getTableLength(arr)
	if length <= 0 then return end
	-- Calculate table union
	local tt = arr[1]
	if length > 1 then
		for i = 2, length, 1 do
			tt = Util:valueUnion(tt, arr[i])
		end
	end
	local str = tostring(tt) .. " = {\n"
	for k, v in pairs(tt) do
		str = str .. tostring(k) .. " = " .. tostring(v) .. ",\n"
	end
	str = str .. "}\n"
	print(str)

end

-- 在线打印类表型数据类型的子集, 多个参数时会打印值的并集
--- @param ... Vector|table|Cube|CubeModel
function onLineDump(...)
	local arr = { ... }
	local length = Util:getTableLength(arr)
	if length <= 0 then onLinePrint("nil") return end
	-- Calculate table union
	local tt = arr[1]
	if length > 1 then
		for i = 2, length, 1 do
			tt = Util:valueUnion(tt, arr[i])
		end
	end
	local str = tostring(tt) .. " = {\n"
	for k, v in pairs(tt) do
		str = str .. tostring(k) .. " = " .. tostring(v) .. ",\n"
	end
	str = str .. "}\n"
	onLinePrint(str)

end

-- 凸多边形点集排序
---comment
---@param ... Vector
---@return table
local function polygonPointArrSort(...)
	local self = Util
	if not self:isPolygon(...) then error("EG=> Not polygon!") end
	local pointArr = type(...) == "table" and ... or { ... }
	local barycenter = self:polygonBaryCenter(pointArr)
	table.sort(pointArr, function(a, b)
		local u = { x = a.x - barycenter.x, y = a.y - barycenter.y }
		local v = { x = b.x - barycenter.x, y = b.y - barycenter.y }
		local crossProduct = self:cross(u, v)
		if crossProduct.z > 0 then -- 逆时针排序
			return true
		elseif crossProduct.z < 0 then
			return false
		else -- 共线时
			local L1 = (a.x - barycenter.x) ^ 2 + (a.y - barycenter.y) ^ 2
			local L2 = (b.x - barycenter.x) ^ 2 + (b.y - barycenter.y) ^ 2
			return L1 < L2
		end
	end)
	return pointArr
end

--==============================================================================================--

---@class Util
Util = {} -- 工具类
-- 随机种子
gameapi.set_random_seed(tostring(os.time()):reverse():sub(1, 7))

-- 插值
--- @param from number
--- @param to number
--- @param time number 值域[0, 1]
function Util:lerp(from, to, time)
	return from + (to - from) * (time < 0 and 0 or time > 1 and 1 or time)
end

-- 队列
--- @return Queue
function Util:creatQueue()
	--- @class Queue
	--- @field push function
	--- @field pop function
	--- @field empty function
	--- @field front function
	--- @field back function
	--- @field size function
	local queue = {}
	local mt = {}
	mt.__index = mt
	setmetatable(queue, mt)

	-- 入队
	--- @param obj any
	mt.push = function(obj)
		table.insert(queue, obj)
	end
	--  出队
	mt.pop = function()
		table.remove(queue, 1)
		if queue.empty() then
			queue = {}
		end
	end
	-- 头元素
	--- @return any
	mt.front = function()
		if queue.empty() then
			error("EG=> queue is nill")
		else
			return queue[1]
		end
	end
	-- 尾元素
	--- @return any
	mt.back = function()
		if queue.empty() then
			error("EG=> queue is nill")
		else
			return queue[self:getTableLength(queue)]
		end
	end
	-- 判空
	--- @return boolean
	mt.empty = function()
		if queue[1] then
			return false
		end
		return true
	end
	-- 大小
	--- @return integer
	mt.size = function()
		return self:getTableLength(queue)
	end
	return queue
end

-- 字符串分割
--- @param input string
--- @param delimiter string
--- @return string ...
function Util:split(input, delimiter)
	if type(delimiter) ~= "string" or #delimiter <= 0 then
		return
	end
	local start = 1
	local arr = {}
	while true do
		local pos = string.find(input, delimiter, start, true)
		if not pos then
			break
		end
		table.insert(arr, string.sub(input, start, pos - 1))
		start = pos + string.len(delimiter)
	end
	table.insert(arr, string.sub(input, start))
	return table.unpack(arr)
end

-- 反转表
function Util:reverseTable(cubeTb)
	local self = Util
	if self:getTableLength(cubeTb) <= 0 then error("EG=> Nil table") end
	-- get keyArr
	local keyArr = {}
	local index = 1
	for k, _ in pairs(cubeTb) do
		keyArr[index] = k
		index = index + 1
	end
	-- reverse keyArr
	local reverseKeyArr = {}
	local length = index - 1
	for i = 1, length, 1 do
		reverseKeyArr[i] = keyArr[length + 1 - i]
	end
	-- reverse table
	local resTable = {}
	for i = 1, length, 1 do
		table.insert(resTable, cubeTb[reverseKeyArr[i]])
	end

	return resTable
end

-- 打乱数组
function Util:shuffle(cubeTb)
	if not cubeTb or self:getTableLength(cubeTb) == 0 then return end
	-- table to array
	local arr = {}
	local keyArr = {}
	for k, v in pairs(cubeTb) do
		table.insert(arr, v)
		table.insert(keyArr, k)
	end
	-- shuffle
	for i = 1, self:getTableLength(arr), 1 do
		local randNum = math.random(1, i)
		arr[i], arr[randNum] = arr[randNum], arr[i]
	end
	-- array to table
	local res = {}
	for i = 1, self:getTableLength(keyArr), 1 do
		res[keyArr[i]] = arr[i]
	end
	return res
end

-- 相等
--- @param cubeTb_1 any
--- @param cubeTb_2 any
--- @return boolean
function Util:equal(cubeTb_1, cubeTb_2)
	-- judge value equal
	if cubeTb_1 == cubeTb_2 then return true end
	-- judge "nil" and not "nil"
	if cubeTb_1 == nil or cubeTb_2 == nil then return false end
	-- judge type
	if type(cubeTb_1) ~= type(cubeTb_2) then return false end

	if type(cubeTb_1) == "table" and type(cubeTb_2) == "table" then
		-- is cube type
		if cubeTb_1.cubeModel and cubeTb_2.cubeModel then
			if cubeTb_1.key == cubeTb_2.key then
				return true
			end
			return false
		elseif cubeTb_1.cubeModel and not cubeTb_2.cubeModel or
			not cubeTb_1.cubeModel and cubeTb_2.cubeModel then
			return false
		end
		-- is cubeModel type
		if cubeTb_1.centerPoint and cubeTb_2.centerPoint then
			if cubeTb_1.centerPoint.x and cubeTb_1.centerPoint.y and cubeTb_1.centerPoint.z and
				cubeTb_2.centerPoint.x and cubeTb_2.centerPoint.y and cubeTb_2.centerPoint.z then
				if math.abs(cubeTb_1.centerPoint.x - cubeTb_2.centerPoint.x) < 0.6 and
					math.abs(cubeTb_1.centerPoint.y - cubeTb_2.centerPoint.y) < 0.6 and
					math.abs(cubeTb_1.centerPoint.z - cubeTb_2.centerPoint.z) < 0.6 then
					return true
				end
				return false
			end
		elseif cubeTb_1.centerPoint and not cubeTb_2.centerPoint or
			not cubeTb_1.centerPoint and cubeTb_2.centerPoint then
			return false
		end
		-- is point type
		if cubeTb_1.x and cubeTb_1.y and cubeTb_1.z and
			cubeTb_2.x and cubeTb_2.y and cubeTb_2.z then
			if math.abs(cubeTb_1.x - cubeTb_2.x) < 0.6 and
				math.abs(cubeTb_1.y - cubeTb_2.y) < 0.6 and
				math.abs(cubeTb_1.z - cubeTb_2.z) < 0.6 then
				return true
			end
			return false
		end
		-- is table<integer, number|string> type
		-- judge table length
		local length_1 = self:getTableLength(cubeTb_1)
		local length_2 = self:getTableLength(cubeTb_2)
		if length_1 ~= length_2 then return false end
		-- judge value
		local t, tt = {}, {}
		for _, v in pairs(cubeTb_1) do table.insert(t, v) end
		for _, v in pairs(cubeTb_2) do table.insert(tt, v) end
		table.sort(t, function(a, b)
			return tostring(a) < tostring(b)
		end)
		table.sort(tt, function(a, b)
			return tostring(a) < tostring(b)
		end)
		local len = 0
		for i = 1, length_1, 1 do
			if type(t[i]) ~= type(tt[i]) then return false end
			if t[i] ~= tt[i] then
				return false
			else
				len = len + 1
			end
		end
		if len == length then return true end
	end
	return false
end

-- 表做值并集
function Util:valueUnion(cubeTb_1, cubeTb_2)
	-- by 'key' is only
	local union = {}
	local cubeTbTemp = {}
	-- Can use table as key
	for k, v in pairs(cubeTb_1) do
		cubeTbTemp[v] = true
	end
	for k, v in pairs(cubeTb_2) do
		cubeTbTemp[v] = true
	end
	for k, v in pairs(cubeTbTemp) do
		table.insert(union, k)
	end
	return union
end

-- 表做值差集
--- @param cubeTb_1 table<integer, any>
--- @param cubeTb_2 table<integer, any>
--- @return table<integer, any>
function Util:valueDiff(cubeTb_1, cubeTb_2)
	if not cubeTb_1 then error("EG=> argument 1 is nil") end
	if not cubeTb_2 then error("EG=> argument 2 is nil") end
	if type(cubeTb_1) ~= "table" then error("EG=> argument 1 type is not table") end
	if type(cubeTb_2) ~= "table" then error("EG=> argument 2 type is not table") end

	if self:getTableLength(cubeTb_1) < self:getTableLength(cubeTb_2) then
		cubeTb_1, cubeTb_2 = cubeTb_2, cubeTb_1
	end
	local resTb = {}
	for k, v in pairs(cubeTb_1) do
		for kk, vv in pairs(cubeTb_2) do
			if self:equal(v, vv) then
				v = nil
			end
		end
		if v then
			resTb[k] = v
		end
	end

	return resTb
end

-- 值是否在表中
--- @param value any
--- @param table table
--- @return boolean
function Util:valueInTable(value, table)
	for k, v in pairs(table) do
		if Util:equal(value, v) then
			return true
		end
	end
	return false
end

-- 获取表长
--- @param cubeTb table
--- @return integer
function Util:getTableLength(cubeTb)
	-- beacuse '#' don't will calculate "nil" and string type index
	if cubeTb == nil then return 0 end
	local length = 0
	for _, v in pairs(cubeTb) do
		length = length + 1
	end
	return length
end

-- 清空表
function Util:clear(cubeTb)
	if cubeTb == nil or cubeTb == {} then return end
	for i = 1, self:getTableLength(cubeTb), 1 do
		table.remove(cubeTb)
	end
	-- collectgarbage

end

-- 删除表值
function Util:remove(cubeTb, value)
	if not cubeTb then error("EG => table is nil") end
	if type(cubeTb) ~= "table" then error("EG => Is not table type") end
	for k, v in pairs(cubeTb) do
		if self:equal(v, value) then
			table.remove(cubeTb, k)
			return cubeTb
		end
	end
end

-- 函数求导
function Util:derivat(f, delta)
	local delta = delta or 10e-10
	return function(x)
		return (f(x + delta) - f(x)) / delta
	end
end

-- 两点间距离
--- @param p1 Vector
--- @param p2 Vector
--- @return number
function Util:distance(p1, p2)
	local x1 = p1.x or 0
	local y1 = p1.y or 0
	local z1 = p1.z or 0

	local x2 = p2.x or 0
	local y2 = p2.y or 0
	local z2 = p2.z or 0

	return math.abs(math.sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2))
end

-- 向量夹角
function Util:includeAngle(u, v)
	u, v = vectorCheck(u, v)

	local Lu = u.x ^ 2 + u.y ^ 2 + u.z ^ 2
	local Lv = v.x ^ 2 + v.y ^ 2 + v.z ^ 2
	if Lv == 0 and Lu == 0 then error("all vector is zero vector!") end
	if Lv == 0 or Lu == 0 then return 0 end
	local multipli = self:multipli(u, v)
	return math.deg(math.acos(multipli / math.sqrt(Lv * Lu))) -- 弧度转角度
end

-- 计算三角形的面积
--- @param p1 Vector
--- @param p2 Vector
--- @param p3 Vector
--- @return number
function Util:triangleArea(p1, p2, p3)
	p1, p2, p3 = vectorCheck(p1, p2, p3)
	if p1 == nil or p2 == nil or p3 == nil or
		self:equal({}, p1) or self:equal({}, p2) or self:equal({}, p3) then
		error("EG=> Args is nil")
	end
	local u = self:creatVector(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z)
	local v = self:creatVector(p2.x - p3.x, p2.y - p3.y, p2.z - p3.z)
	return self:vectorLength(self:cross(u, v)) / 2
end

-- 判定向量平行
function Util:isVectorParallel(vec1, vec2)
	vec1, vec2 = vectorCheck(vec1, vec2)
	-- precision of 2, like "2.01" and "1.00"
	local a = math.modf(vec1.x / vec2.x * 10 ^ 2) / 10 ^ 2
	local b = math.modf(vec1.y / vec2.y * 10 ^ 2) / 10 ^ 2
	local c = math.modf(vec1.z / vec2.z * 10 ^ 2) / 10 ^ 2
	return self:equal(a, b) and self:equal(a, c)
end

-- 判定点集是否为多边形
--- @param ... Vector
--- @return boolean
function Util:isPolygon(...)
	local pointArr = { ... }
	for _, v in pairs(pointArr) do
		v = vectorCheck(v)
	end
	local length = self:getTableLength(pointArr)
	-- Judgment quantity
	if length < 3 then error("EG=> Missing parameter") end
	-- Determine the number of non-coincidence points
	local boolArr = {}
	for i = 1, length, 1 do
		boolArr[i] = false
	end
	for i = 1, length - 1, 1 do
		for j = i + 1, length, 1 do
			if self:equal(pointArr[i], pointArr[j]) then
				boolArr[j] = true
			end
		end
	end
	local len = 0
	local newPointArr = {}
	for i = 1, self:getTableLength(boolArr), 1 do
		if boolArr[i] == true then
			len = len + 1
		else
			table.insert(newPointArr, pointArr[i])
		end
	end
	if length - len < 3 then return false end
	-- Determine whether the normal vectors on all surfaces are parallel
	local vectorArr = {}
	for i = 1, self:getTableLength(newPointArr) - 2, 1 do
		local vec1 = {
			x = newPointArr[i].x - newPointArr[i + 1].x,
			y = newPointArr[i].y - newPointArr[i + 1].y,
			z = newPointArr[i].z - newPointArr[i + 1].z
		}
		local vec2 = {
			x = newPointArr[i].x - newPointArr[i + 2].x,
			y = newPointArr[i].y - newPointArr[i + 2].y,
			z = newPointArr[i].z - newPointArr[i + 2].z
		}
		table.insert(vectorArr, self:cross(vec1, vec2))
	end
	local leng = self:getTableLength(vectorArr)
	for i = 1, leng - 1, 1 do
		for j = i + 1, leng, 1 do
			if not self:isVectorParallel(vectorArr[i], vectorArr[j]) then
				return false
			end
		end
	end
	return true
end

-- 计算任意多边形的重心
--- @param ... Vector
--- @return Vector
function Util:polygonBaryCenter(...)
	if not self:isPolygon(...) then error("EG=> Not polygon!") end
	local pointArr = { ... }
	local length = self:getTableLength(pointArr)
	local point = self:creatVector(0, 0, 0)
	local areaSum = 0
	local axSum = 0
	local aySum = 0
	local azSum = 0
	for i = 1, length - 2, 1 do
		local p1 = pointArr[i]
		local p2 = pointArr[i + 1]
		local p3 = pointArr[i + 2]
		local area = self:triangleArea(p1, p2, p3)
		axSum = axSum + area * (p1.x + p2.x + p3.x)
		aySum = aySum + area * (p1.y + p2.y + p3.y)
		azSum = azSum + area * (p1.z + p2.z + p3.z)
		areaSum = areaSum + area
	end
	point.x = axSum / (3 * areaSum)
	point.y = aySum / (3 * areaSum)
	point.z = azSum / (3 * areaSum)
	return point
end

-- 计算任意多边形的面积
function Util:polygonArea(...)
	local pointArr = { ... }
	local length = self:getTableLength(pointArr)
	if length < 3 then return 0 end
	local result = 0
	for i = 1, length, 1 do
		local multiVector3 = self:cross(pointArr[i], pointArr[i % length + 1])
		result = result + multiVector3.z
	end
	return 1 / 2 * math.abs(result)
end

-- 计算向量模长
--- @param vector Vector
--- @return number
function Util:vectorLength(vector)
	vector = vectorCheck(vector)
	return math.sqrt(vector.x ^ 2 + vector.y ^ 2 + vector.z ^ 2)
end

-- 判断向量是否同向
--- @param vec1 Vector
---@param vec2 Vector
function Util:isDirectionSame(vec1, vec2)
	vec1, vec2 = vectorCheck(vec1, vec2)
	if vec2.x == 0 and vec1.x ~= 0 or
		vec2.y == 0 and vec1.y ~= 0 or
		vec2.z == 0 and vec1.z ~= 0 then
		return false
	end
	local a = vec1.x / vec2.x
	local b = vec1.y / vec2.y
	local c = vec1.z / vec2.z
	local isSameDirection = true
	if not (math.abs(a - b) < 1e-6 and math.abs(a - c) < 1e-6) then
		isSameDirection = false
	end
	if a < 0 or b < 0 or c < 0 then
		isSameDirection = false
	end
	return isSameDirection
end

-- 欧拉角转换为四元数
function Util:toQuaternion(euler)
	local pitch = euler.pitch or 0
	local yaw = euler.yaw or 0
	local roll = euler.roll or 0

	local cos = math.cos
	local sin = math.sin
	local R = roll / 2
	local P = pitch / 2
	local Y = yaw / 2
	local w = cos(R) * cos(P) * cos(Y) + sin(R) * sin(P) * sin(Y)
	local x = sin(R) * cos(P) * cos(Y) - cos(R) * sin(P) * sin(Y)
	local y = cos(R) * sin(P) * cos(Y) + sin(R) * cos(P) * sin(Y)
	local z = cos(R) * cos(P) * sin(Y) - sin(R) * sin(P) * cos(Y)
	return { x = x, y = y, z = z, w = w }
end

-- 返回弧度表示的y/x的反正切
function Util:atan2(y, x)
	if x > 0 then return math.atan(y / x) end
	if y >= 0 and x < 0 then return math.atan(y / x) + math.pi end
	if y < 0 and x < 0 then return math.atan(y / x) - math.pi end
	if y > 0 and self:equal(x, 0) then return math.pi / 2 end
	if y < 0 and self:equal(x, 0) then return -math.pi / 2 end
	if self:equal(y, 0) and self:equal(x, 0) then error("y and x is zero!") end
end

-- 四元数转换为欧拉角
function Util:toEuler(quaternion)
	local q1 = quaternion.x or 0
	local q2 = quaternion.y or 0
	local q3 = quaternion.z or 0
	local q0 = quaternion.w or 0

	local R = self:atan2(2 * (q1 * q2 + q3 * q0), 1 - 2 * (q2 ^ 2 + q3 ^ 2))
	local P = math.asin(2 * (q1 * q2 - q3 * q0))
	local Y = self:atan2(2 * (q1 * q0 + q2 * q3), 1 - 2 * (q3 ^ 2 + q0 ^ 2))
	return R, P, Y
end

-- 叉乘
--- @param p1 Vector
--- @param p2 Vector
--- @return Vector
function Util:cross(p1, p2)
	p1, p2 = vectorCheck(p1, p2)
	return self:creatVector(p1.y * p2.z - p2.y * p1.z, p1.z * p2.x - p2.z * p1.x, p1.x * p2.y - p2.x * p1.y)
end

-- 点乘
--- @param p1 Vector
--- @param p2 Vector
--- @return number
function Util:multipli(p1, p2)
	p1, p2 = vectorCheck(p1, p2)
	return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z
end

-- 构造向量
--- @class Vector
--- @field x number
--- @field y number
--- @field z number
--- @param x number
--- @param y number
--- @param z number
--- @return Vector
function Util:creatVector(x, y, z)
	if not x then error("EG=> param #1 is nil") end
	if not y then error("EG=> param #2 is nil") end
	if not z then error("EG=> param #3 is nil") end
	return {
		x = x,
		y = y,
		z = z
	}
end

-- 构造射线
--- @class Ray
--- @field origin Vector
--- @field vector Vector
--- @param ori Vector
--- @param vec Vector
--- @return Ray
function Util:creatRay(ori, vec)
	ori, vec = vectorCheck(ori, vec)
	return {
		origin = ori,
		vector = vec
	}
end

-- 构造空间平面
--- @class Plane
--- @field p1 Vector
--- @field p2 Vector
--- @field p3 Vector
--- @field p4 Vector
--- @field barycenter Vector
--- @param ... Vector
--- @return Plane
function Util:creatPlane(...)
	local tb = { ... }
	local length = self:getTableLength(tb)
	if length < 3 then error("EG=> There are not enough points to form a plane") end
	for i = 1, length - 1, 1 do
		for j = i + 1, length, 1 do
			if self:equal(tb[i], tb[j]) then
				error("EG=> Dot repetition!")
			end
		end
	end
	local resTb = {}
	for k, v in ipairs(tb) do
		resTb["p" .. k] = v
	end
	-- resTb.barycenter = self:polygonBaryCenter(table.unpack(tb)) -- 接口没有测试,有点问题
	resTb.barycenter = self:creatVector(
		(resTb.p2.x + resTb.p1.x) / 2,
		(resTb.p2.y + resTb.p3.y) / 2,
		(resTb.p3.z + resTb.p1.z) / 2
	)
	return resTb
end

-- 创建立方体的数学模型
--- @class CubeModel
--- @field centerPoint Vector
--- @field planeTable table<string, Plane>
--- @field length number
--- @field width number
--- @field height number
--- @field p1 Vector
--- @field p2 Vector
--- @field p3 Vector
--- @field p4 Vector
--- @field p5 Vector
--- @field p6 Vector
--- @field p7 Vector
--- @field p8 Vector
--- @param barycenter Vector
--- @param length number
--- @param width number
--- @param height number
--- @return CubeModel
function Util:creatCubeModel(barycenter, length, width, height)
	if barycenter == nil or length == nil or width == nil or height == nil then
		error("EG=> Args is nil")
	end
	if length == 0 or width == 0 or height == 0 then
		error("EG=> The side length is 0")
	end
	-- Compute each vertex
	local p1 = self:creatVector(barycenter.x - length / 2, barycenter.y - width / 2, barycenter.z + height / 2)
	local p2 = self:creatVector(barycenter.x + length / 2, barycenter.y - width / 2, barycenter.z + height / 2)
	local p3 = self:creatVector(barycenter.x + length / 2, barycenter.y + width / 2, barycenter.z + height / 2)
	local p4 = self:creatVector(barycenter.x - length / 2, barycenter.y + width / 2, barycenter.z + height / 2)
	local p5 = self:creatVector(barycenter.x - length / 2, barycenter.y - width / 2, barycenter.z - height / 2)
	local p6 = self:creatVector(barycenter.x + length / 2, barycenter.y - width / 2, barycenter.z - height / 2)
	local p7 = self:creatVector(barycenter.x + length / 2, barycenter.y + width / 2, barycenter.z - height / 2)
	local p8 = self:creatVector(barycenter.x - length / 2, barycenter.y + width / 2, barycenter.z - height / 2)
	-- Compute each plane
	--- @type table<string, Plane>
	local planeTable = {
		TOP = self:creatPlane(p1, p2, p3, p4),
		BOTTOM = self:creatPlane(p5, p6, p7, p8),
		LEFT = self:creatPlane(p1, p4, p8, p5),
		RIGHT = self:creatPlane(p2, p3, p7, p6),
		FRONT = self:creatPlane(p3, p4, p8, p7),
		BACK = self:creatPlane(p1, p2, p6, p5)
	}
	return {
		centerPoint = barycenter,
		planeTable = planeTable,
		length = length,
		width = width,
		height = height,
		p1 = p1,
		p2 = p2,
		p3 = p3,
		p4 = p4,
		p5 = p5,
		p6 = p6,
		p7 = p7,
		p8 = p8
	}
end

-- 判断射线是否穿过空间平面，并返回相交点
--- @param ray Ray
--- @param plane Plane
--- @return boolean, Vector
function Util:isRayHitSpacePlane(ray, plane)
	-- "n" is space plane normal vector
	local vec1 = self:creatVector(plane.p3.x - plane.p1.x, plane.p3.y - plane.p1.y, plane.p3.z - plane.p1.z)
	local vec2 = self:creatVector(plane.p2.x - plane.p1.x, plane.p2.y - plane.p1.y, plane.p2.z - plane.p1.z)
	--[[
		simultaneous equations:
		ray: p = origin + t * vector, t >= 0
		plane: n * (p - p1) = 0
		=>  t = n * (p1 - origin) / n * vector
	--]]
	local n = self:cross(vec1, vec2)
	local b = self:multipli(n, ray.vector)
	local vec = self:creatVector(plane.p1.x - ray.origin.x, plane.p1.y - ray.origin.y, plane.p1.z - ray.origin.z)
	local t = self:multipli(n, vec) / b
	if t >= 0 then
		return true, self:creatVector(
			ray.origin.x + t * ray.vector.x,
			ray.origin.y + t * ray.vector.y,
			ray.origin.z + t * ray.vector.z
		)
	end
	return false
end

-- 获取射线首次打中立方体的最近面的交点和面名
--- @param ray Ray
--- @param cubeModel CubeModel
--- @return Vector, string
function Util:getRayHitCubeInersectionPointAndPlaneName(ray, cubeModel)
	if not ray then error("EG=> param #1 is nil") end
	if not cubeModel then error("EG=> param #2 is nil") end
	-- Determine whether it points to the surface and is in the surface
	local minDistance = math.maxinteger
	local intersectionPoint = nil
	local resPlaneName = nil
	for name, plane in pairs(cubeModel.planeTable) do
		repeat
			local isHitPlane, point = self:isRayHitSpacePlane(ray, plane) -- 相交检测
			if not isHitPlane then
				break
			end
			-- onLinePrint("相交检测:", name)
			local inPlane = false
			if name == "TOP" then
				if point.x <= cubeModel.p2.x and point.x >= cubeModel.p1.x and
					point.y <= cubeModel.p4.y and point.y >= cubeModel.p1.y then
					inPlane = true
				end
			end
			if name == "BOTTOM" then
				if point.x <= cubeModel.p6.x and point.x >= cubeModel.p5.x and
					point.y <= cubeModel.p8.y and point.y >= cubeModel.p5.y then
					inPlane = true
				end
			end
			if name == "LEFT" then
				if point.z <= cubeModel.p1.z and point.z >= cubeModel.p5.z and
					point.y <= cubeModel.p8.y and point.y >= cubeModel.p5.y then
					inPlane = true
				end
			end
			if name == "RIGHT" then
				if point.z <= cubeModel.p2.z and point.z >= cubeModel.p6.z and
					point.y <= cubeModel.p7.y and point.y >= cubeModel.p6.y then
					inPlane = true
				end
			end
			if name == "FRONT" then
				if point.z <= cubeModel.p3.z and point.z >= cubeModel.p7.z and
					point.x <= cubeModel.p7.x and point.x >= cubeModel.p8.x then
					inPlane = true
				end
			end
			if name == "BACK" then
				if point.z <= cubeModel.p1.z and point.z >= cubeModel.p5.z and
					point.x <= cubeModel.p6.x and point.x >= cubeModel.p5.x then
					inPlane = true
				end
			end
			if not inPlane then
				break
			end
			-- print("点在面上:", inPlane)
			local distance = self:distance(ray.origin, point)
			-- print(distance)
			if minDistance > distance then
				minDistance = distance
				intersectionPoint = point
				resPlaneName = name
			end
		until true
	end
	return intersectionPoint, resPlaneName
end

-- 点在立方体内
--- @param point Vector
--- @param cubeModel CubeModel
--- @return boolean
function Util:isPointInCube(point, cubeModel)
	local minX = cubeModel.p1.x
	local maxX = cubeModel.p2.x
	local minY = cubeModel.p1.y
	local maxY = cubeModel.p4.y
	local minZ = cubeModel.p5.z
	local maxZ = cubeModel.p1.z
	if point.x <= maxX and point.x >= minX and
		point.y <= maxY and point.y >= minY and
		point.z <= maxZ and point.z >= minZ then
		return true
	end
	return false
end

-- 点到空间平面的距离
--- @param point Vector
--- @param plane Plane
--- @return number
function Util:pointToPlaneDistance(point, plane)
	local x = point.x - plane.p1.x
	local y = point.y - plane.p1.y
	local z = point.z - plane.p1.z
	local vector = self:creatVector(x, y, z)
	local xx = plane.p1.x - plane.p2.x
	local yy = plane.p1.y - plane.p2.y
	local zz = plane.p1.z - plane.p2.z
	local vec1 = self:creatVector(xx, yy, zz)
	local xxx = plane.p3.x - plane.p2.x
	local yyy = plane.p3.y - plane.p2.y
	local zzz = plane.p3.z - plane.p2.z
	local vec2 = self:creatVector(xxx, yyy, zzz)
	local n = self:cross(vec1, vec2)
	return math.abs(self:multipli(vector, n)) / self:vectorLength(n)
end

-- 获取点到立方体的最近面,距离和面名
--- @param point Vector
--- @param cubeModel CubeModel
--- @return Plane, number, string
function Util:getPointToCubeMinPlane(point, cubeModel)
	local minDistancePlane = cubeModel.planeTable.TOP -- 初始化最近面
	local minDistance = self:pointToPlaneDistance(point, cubeModel.planeTable.TOP) -- 初始化最近距离
	local minPlaneName = "TOP" -- 初始化最近面名
	--- @param plane Plane
	for name, plane in pairs(cubeModel.planeTable) do
		local distance = self:pointToPlaneDistance(point, plane)
		-- print(minDistance, distance, name)
		if minDistance - distance > 1 then -- 数据误差在1以内算相等,避免在棱边上的情况
			minDistance = distance
			minDistancePlane = plane
			minPlaneName = name
		end
	end
	return minDistancePlane, minDistance, minPlaneName
end

return Util
